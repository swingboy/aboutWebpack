<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<title>webpackFlow</title>


<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>


</head>

<body>

<h1 id="toc_0">webpack 原理</h1>

<h2 id="toc_1">webpack核心概念</h2>

<p>entry 一个可执行模块或库的入口文件。</p>

<p>chunk 多个文件组成的一个代码块，例如把一个可执行模块和它所有依赖的模块组合和一个 chunk. </p>

<p>loader 文件转换器，例如把es6转换为es5，scss转换为css。</p>

<p>plugin 插件，用于扩展webpack的功能，在webpack构建生命周期的节点上加入扩展hook为webpack添加功能。  </p>

<h3 id="toc_2">webpack 模块？</h3>

<p>对比 Node.js 模块，webpack 模块能够以各种方式表达它们的依赖关系，几个例子如下：</p>

<p>ES2015 import 语句 
CommonJS require() 语句 
AMD define 和 require 语句 
css/sass/less 文件中的 @import 语句 
样式(url(...))或 HTML 文件(&lt;img src=...&gt;)中的图片链接(image url) </p>

<h3 id="toc_3">支持的模块类型</h3>

<p>webpack 通过 loader 可以支持各种语言和预处理器编写模块。loader 描述了 webpack 如何处理 非 JavaScript(non-JavaScript) 模块，并且在bundle中引入这些依赖。 webpack 社区已经为各种流行语言和语言处理器构建了 loader，包括：</p>

<ul>
<li>CoffeeScript</li>
<li>TypeScript</li>
<li>ESNext (Babel)</li>
<li>Sass</li>
<li>Less</li>
<li>Stylus</li>
</ul>

<h3 id="toc_4">事件系统</h3>

<p>Webpack的基础组件之一Tapable是为其量身定做的“EventEmitter”，但它不只是单纯的事件中枢，还相应补充了对事件流程的控制能力，增加了如waterfall/series/parallel系列方法，实现了同步/异步、顺序/并行等事件流的控制能力。</p>

<ul>
<li>发布/订阅模式</li>
</ul>

<h2 id="toc_5">webpack构建流程 总括</h2>

<p>解析webpack配置参数，合并从shell传入和webpack.config.js文件里配置的参数，生产最后的配置结果。</p>

<p>注册所有配置的插件，好让插件监听webpack构建生命周期的事件节点，以做出对应的反应。 </p>

<p>从配置的entry入口文件开始解析文件构建AST语法树，找出每个文件所依赖的文件，递归下去。 </p>

<p>在解析文件递归的过程中根据文件类型和loader配置找出合适的loader用来对文件进行转换。  </p>

<p>递归完后得到每个文件的最终结果，根据entry配置生成代码块chunk。  </p>

<p>输出所有chunk到文件系统。  </p>

<ul>
<li>在构建生命周期中有一系列插件在合适的时机做了合适的事情，比如一些插件的操作。</li>
<li>Webpack 会在特定的时间点广播出特定的事件</li>
</ul>

<h3 id="toc_6">1. webpack入口（webpack.config.js和shell options）</h3>

<p>从配置文件package.json 和 Shell 语句中读取与合并参数，得出最终的参数；</p>

<p>每次在命令行输入 webpack 后，操作系统都会去调用 ./node<em>modules/.bin/webpack 这个 shell 脚本。这个脚本会去调用 ./node</em>modules/webpack/bin/webpack.js </p>

<ul>
<li>开一个子进程处理 cli</li>
</ul>

<h3 id="toc_7">2. 用yargs参数解析</h3>

<div><pre><code class="language-none">// webpack/bin/webpack.js =&gt; webpack-cli/bin/cli.js
yargs.parse(process.argv.slice(2), (err, argv, output) =&gt; {
</code></pre></div>

<h3 id="toc_8">3.webpack初始化</h3>

<p>（1）构建compiler对象</p>

<div><pre><code class="language-none">// webpack-cli/bin/cli.js
let lastHash = null;
let compiler;
try {
    compiler = webpack(options);

...
compiler = new Compiler(options.context);
</code></pre></div>

<ul>
<li>还会某些阶段注册一些钩子，compiler.hooks.watchRun、beforeRun、done</li>
</ul>

<p>（2）注册NodeEnvironmentPlugin插件</p>

<div><pre><code class="language-none">// 在webpack/lib/webpack.js 
new NodeEnvironmentPlugin().apply(compiler);</code></pre></div>

<div><pre><code class="language-none">//NodeEnvironmentPlugin.js
apply(compiler) {
    compiler.inputFileSystem = new CachedInputFileSystem(
        new NodeJsInputFileSystem(),
        60000
    );
    const inputFileSystem = compiler.inputFileSystem;
    compiler.outputFileSystem = new NodeOutputFileSystem();
    compiler.watchFileSystem = new NodeWatchFileSystem(
        compiler.inputFileSystem
    );
    // 注册beforeRun
    compiler.hooks.beforeRun.tap(&quot;NodeEnvironmentPlugin&quot;, compiler =&gt; {
        if (compiler.inputFileSystem === inputFileSystem) inputFileSystem.purge();
    });
}</code></pre></div>

<p>（3）挂载options中的基础插件，调用WebpackOptionsApply库初始化基础插件。</p>

<div><pre><code class="language-none">//webpack/lib/webpack.js
compiler.options = options;
new NodeEnvironmentPlugin().apply(compiler);
if (options.plugins &amp;&amp; Array.isArray(options.plugins)) {
    for (const plugin of options.plugins) {
        if (typeof plugin === &quot;function&quot;) {
            plugin.apply(compiler);
        } else {
            plugin.apply(compiler);
        }
    }
}
compiler.hooks.environment.call();
compiler.hooks.afterEnvironment.call();
//调用WebpackOptionsApply库初始化基础插件。
compiler.options = new WebpackOptionsApply().process(options, compiler);



//  WebpackOptionsApply
class WebpackOptionsApply extends OptionsApply {
    constructor() {
        super();
    }

    /**
     * @param {WebpackOptions} options options object
     * @param {Compiler} compiler compiler object
     * @returns {WebpackOptions} options object
     */
    process(options, compiler) {
        // 一堆基础插件
        ...
        let ExternalsPlugin;
        new JsonpTemplatePlugin().apply(compiler);
        new FetchCompileWasmTemplatePlugin({
            mangleImports: options.optimization.mangleWasmImports
        }).apply(compiler);
        new FunctionModulePlugin().apply(compiler);
        new NodeSourcePlugin(options.node).apply(compiler);
        new LoaderTargetPlugin(options.target).apply(compiler);
        ....
    }</code></pre></div>

<p>（4） run 开始编译(compiler.run)</p>

<div><pre><code class="language-none">// webpack/lib/webpack.js
if (
    options.watch === true ||
    (Array.isArray(options) &amp;&amp; options.some(o =&gt; o.watch))
) {
    const watchOptions = Array.isArray(options)
        ? options.map(o =&gt; o.watchOptions || {})
        : options.watchOptions || {};
    return compiler.watch(watchOptions, callback);
}
compiler.run(callback);
</code></pre></div>

<p>实例compiler后根据options的watch判断是否启动了watch，如果启动watch了就调用compiler.watch来监控构建文件</p>

<div><pre><code class="language-none">if (
    options.watch === true ||
    (Array.isArray(options) &amp;&amp; options.some(o =&gt; o.watch))
) {
    const watchOptions = Array.isArray(options)
        ? options.map(o =&gt; o.watchOptions || {})
        : options.watchOptions || {};
    return compiler.watch(watchOptions, callback);
}</code></pre></div>

<ul>
<li><p>这么分析来，webpack的实际入口是Compiler类的run方法</p></li>
<li><p>注： 这些事情都是在 webpack/lib/webpack.js做掉</p></li>
</ul>

<p>在 run 方法里做了哪些事情了 ？</p>

<div><pre><code class="language-none">//compiler.js 的 run 方法
...
this.hooks.beforeRun.callAsync(this, err =&gt; {
    if (err) return finalCallback(err);

    this.hooks.run.callAsync(this, err =&gt; {
        if (err) return finalCallback(err);

        this.readRecords(err =&gt; {
            if (err) return finalCallback(err);

            this.compile(onCompiled);
        });
    });
});
...
后面会执行、触发 this.compile (见下面分析)</code></pre></div>

<h3 id="toc_9">5.触发compile</h3>

<p>（1）在run的过程中，已经触发了一些钩子：beforeRun-&gt;run-&gt;beforeCompile（在complie方法中this.hooks.beforeCompile）-&gt;compile(this.hooks.beforeCompile回调中)-&gt;make-&gt;seal(compilation.seal)</p>

<ul>
<li>其中很多钩子已经注册。beforeCompile 在构建complier 时已经完成</li>
</ul>

<p>（2）构建了Compilation对象</p>

<p>在run()方法中，执行了this.compile（）</p>

<p>this.compile()中创建了compilation 见如下代码：</p>

<div><pre><code class="language-none">// complier.js 的 compile
compile(callback) {
    const params = this.newCompilationParams();
    this.hooks.beforeCompile.callAsync(params, err =&gt; {
        ...
        //回到hook 里面，可以看看实现
        this.hooks.compile.call(params);
        const compilation = this.newCompilation(params);
        // 这里触发make 分析入口等（见下面）
        this.hooks.make.callAsync(compilation, err =&gt; {
            ...
            compilation.finish();
            compilation.seal(err =&gt; {
                ...
                this.hooks.afterCompile.callAsync(compilation, err 
                    ...
                    return callback(null, compilation);
                });
            });
        });
    });
}</code></pre></div>

<ul>
<li><p>Compilation负责整个编译过程，包含了每个构建环节所对应的方法。对象内部保留了对compiler的引用。</p></li>
<li><p>当 Webpack 以开发模式运行时，每当检测到文件变化，一次新的 Compilation 将被创建。</p></li>
<li><p>Compilation很重要！编译生产资源变换文件都靠它。</p></li>
</ul>

<h3 id="toc_10">6.addEntry() make 分析入口文件创建模块对象</h3>

<div><pre><code class="language-none">//complier 中的 make钩子
this.hooks.make = new AsyncParallelHook([&quot;compilation&quot;])</code></pre></div>

<p>compile中触发hooks.make(异步)事件并调用addEntry</p>

<p>webpack的make钩子中, tapAsync注册了一个DllEntryPlugin, 就是将入口模块通过调用compilation。（下面有注册代码）</p>

<p>这一注册在Compiler.compile()方法中被执行。</p>

<p>addEntry方法将所有的入口模块添加到编译构建队列中，开启编译流程。</p>

<div><pre><code class="language-none">//DllEntryPlugin.js
compiler.hooks.make.tapAsync(&quot;DllEntryPlugin&quot;, (compilation, callback) =&gt; {
    compilation.addEntry(
        this.context,
        new DllEntryDependency(
            this.entries.map((e, idx) =&gt; {
                const dep = new SingleEntryDependency(e);
                dep.loc = {
                    name: this.name,
                    index: idx
                };
                return dep;
            }),
            this.name
        ),
        this.name,
        callback
    );
});</code></pre></div>

<p>解释下为什么流程走到这里</p>

<p>之前WebpackOptionsApply.process()初始化插件的时候，执行了compiler.hooks.entryOption.call(options.context, options.entry);</p>

<div><pre><code class="language-none">//WebpackOptionsApply.js
class WebpackOptionsApply extends OptionsApply {
    process(options, compiler) {
        ...
        //这句是关键，注册entryOption钩子
        new EntryOptionPlugin().apply(compiler);
        compiler.hooks.entryOption.call(options.context, options.entry);
    }
}</code></pre></div>

<p>但是entryOption钩子 又是在哪里注册的呢？<br>
答：在EntryOptionPlugin中</p>

<div><pre><code class="language-none">compiler.hooks.entryOption.tap(&quot;EntryOptionPlugin&quot;, (context, entry) =&gt; {
    if (typeof entry === &quot;string&quot; || Array.isArray(entry)) {
        itemToPlugin(context, entry, &quot;main&quot;).apply(compiler);
    } else if (typeof entry === &quot;object&quot;) {
        for (const name of Object.keys(entry)) {
            itemToPlugin(context, entry[name], name).apply(compiler);
        }
    } else if (typeof entry === &quot;function&quot;) {
        new DynamicEntryPlugin(context, entry).apply(compiler);
    }
    return true;
});</code></pre></div>

<p>itemToPlugin =&gt; new SingleEntryPlugin(context, item, name) 
 =&gt; </p>

<div><pre><code class="language-none">//SingleEntryPlugin
compilation.dependencyFactories</code></pre></div>

<p>=&gt; compilation.addEntry(context, dep, name, callback);(这就到了构建莫板块)</p>

<p>流弊~~~~</p>

<p>各种插件穿梭~~~</p>

<h3 id="toc_11">7. 构建模块</h3>

<p>compilation.addEntry中执行 _addModuleChain() (下面有代码)这个方法主要做了两件事情。</p>

<p>一是根据模块的类型获取对应的模块工厂并创建模块，二是构建模块。</p>

<div><pre><code class="language-none">//Compilation.js
addEntry(context, entry, name, callback) {
    const slot = {
        name: name,
        request: entry.request,
        module: null
    };
    this._preparedEntrypoints.push(slot);
    this._addModuleChain(
        context,
        entry,
        module =&gt; {
            this.entries.push(module);
        },
        (err, module) =&gt; {
            if (err) {
                return callback(err);
            }

            if (module) {
                slot.module = module;
            } else {
                const idx = this._preparedEntrypoints.indexOf(slot);
                this._preparedEntrypoints.splice(idx, 1);
            }
            return callback(null, module);
        }
    );
}

=&gt; addModule(module, cacheGroup) =&gt; compilation.addModuleDependencies =&gt; 
后面是对于各个模块的解析等</code></pre></div>

<p>然后通过 ModuleFactory.create方法创建模块，比如创建了NormalModual(里面有loaders等)</p>

<p>然后调用里面的doBuild方法=》 runLoaders() (在这里面有个而loader-runner。这是webpack的loader运行器。) </p>

<p>打个断点</p>

<p>插播一下loader的运行总体流程</p>

<ul>
<li>使用loaderResolver解析loader模块路径</li>
<li>根据rule.modules创建RulesSet规则集</li>
<li>使用loader-runner运行loader</li>
</ul>

<p>继续断点~</p>

<p>然后对模块使用的loader进行加载。调用 acorn 解析经 loader 处理后的源文件生成抽象语法树 AST。遍历 AST，构建该模块所依赖的模块</p>

<div><pre><code class="language-none">//NormalModual.js
//产生source，生成语法树
this._source = this.createSource(
    this.binary ? asBuffer(source) : asString(source),
    resourceBuffer,
    sourceMap
);
this._ast =
    typeof extraInfo === &quot;object&quot; &amp;&amp;
    extraInfo !== null &amp;&amp;
    extraInfo.webpackAST !== undefined
        ? extraInfo.webpackAST
        : null;</code></pre></div>

<div><pre><code class="language-none">//NormalModual.js
//调用相应的loader对resource进行加工，生成一段js代码后交给acorn解析生成AST.所以不管是css文件，还是jpg文件，还是html模版，最终经过loader处理会变成一个module：一段js代码。
return this.doBuild(options, compilation, resolver, fs, err =&gt; {
    //回调里面解析ast
    try {
        // 有个Parse类，本质还是acorn
        const result = this.parser.parse(
            this._ast || this._source.source(),
            {
                current: this,
                module: this,
                compilation: compilation,
                options: options
            },
            (err, result) =&gt; {
                if (err) {
                    handleParseError(err);
                } else {
                    handleParseResult(result);
                }
            }
        );
        if (result !== undefined) {
            // parse is sync
            handleParseResult(result);
        }
    } catch (e) {
        handleParseError(e);
    }
});</code></pre></div>

<h4 id="toc_12">使用acorn生成AST，并遍历AST收集依赖</h4>

<p>webpack使用acorn解析每一个经loader处理过的source，并且成AST</p>

<div><pre><code class="language-none">const ast = acornParser.parse(source, {
    ranges: true,
    locations: true,
    ecmaVersion: 2019,
    sourceType: &quot;module&quot;,
    onComment: comments
});
</code></pre></div>

<ul>
<li>调用 loaders 对模块的原始代码进行编译，转换成标准的JS代码</li>
<li>调用 acorn 对JS代码进行语法分析，然后收集其中的依赖关系。每个模块都会记录自己的依赖关系，从而形成一颗关系树</li>
</ul>

<h3 id="toc_13">8. 封装构建结果（seal）</h3>

<p>webpack 会监听 seal事件调用各插件对构建后的结果进行封装，要逐次对每个 module 和 chunk 进行整理，生成编译后的源码，合并，拆分，生成 hash。webpack会根据不同的插件，如MinChunkSizePlugin,LimitChunkCountPlugin 将不同的module整理到不同的chunk里，每个chunk最终对应一个输出文件。 同时这是我们在开发时进行代码优化和功能添加的关键环节。</p>

<p>然后通过Template生成结果代码</p>

<p>插播一下Template</p>

<ul>
<li>Template是用来生成结果代码的。webpack中Template有四个子类：</li>
<li>MainTemplate.js 用于生成项目入口文件<br></li>
<li>ChunkTemplate.js 用于生成异步加载的js代码<br></li>
<li>ModuleTemplate.js 用于生成某个模块的代码<br></li>
<li>HotUpdateChunkTemplate.js</li>
</ul>

<p><em>Template 也是 继承自Tapable，有render方法等</em></p>

<p>然后通过这些模板把chunk生产<strong>webpack_require</strong>的格式。</p>

<h3 id="toc_14">9. 输出资源（emit）</h3>

<p>webpack会在Compiler的emitAssets方法里把compilation.assets里的结果写到输出文件里，在此前会先创建输出目录(把Assets输出到output的path中)。</p>

<div><pre><code class="language-none">emitAssets(compilation, callback) {
    let outputPath;
    const emitFiles = err =&gt; {
        if (err) return callback(err);

        asyncLib.forEachLimit(
            compilation.assets,
            15,
            (source, file, callback) =&gt; {
                ....
                if (targetFile.match(/\/|\\/)) {
                    const dir = path.dirname(targetFile);
                    this.outputFileSystem.mkdirp(
                        this.outputFileSystem.join(outputPath, dir),
                        writeOut
                    );
                } else {
                    writeOut();
                }
            },
            err =&gt; {
                if (err) return callback(err);

                this.hooks.afterEmit.callAsync(compilation, err =&gt; {
                    if (err) return callback(err);

                    return callback();
                });
            }
        );
    };

    this.hooks.emit.callAsync(compilation, err =&gt; {
        if (err) return callback(err);
        outputPath = compilation.getPath(this.outputPath);
        this.outputFileSystem.mkdirp(outputPath, emitFiles);
    });
}</code></pre></div>

<ul>
<li>当要开发一些自定义的 插件要输出一些结果时，把文件放入compilation.assets里即可。</li>
</ul>

<h3 id="toc_15">and more</h3>

<h4 id="toc_16">memory-fs 内存文件系统</h4>

<p>是node原生fs模块内存版(in-memory)的完整功能实现。相比于从磁盘读写数据，memory-fs是内存缓存和快速数据处理的完美替代方案。</p>

<ul>
<li><p>webpack 通过自己实现的memory-fs将 bundle.js 文件打包到了内存中，访问内存中的代码文件也就更快，也减少了代码写入文件的开销。</p></li>
<li><p>memory-fs 是 webpack-dev-middleware 的一个依赖库，webpack-dev-middleware 将 webpack 原本的outputFileSystem 替换成了MemoryFileSystem实例，这样代码就将输出到内存中。</p></li>
</ul>

<div><pre><code class="language-none">//webpack-dev-middleware 中该部分代码
//webpack-dev-middleware/lib/Shared.js
var isMemoryFs = !compiler.compilers &amp;&amp; compiler.outputFileSystem instanceof MemoryFileSystem;
if(isMemoryFs) {
    fs = compiler.outputFileSystem;
} else {
    fs = compiler.outputFileSystem = new MemoryFileSystem();
}</code></pre></div>

<ul>
<li>首先判断当前 fileSystem 是否已经是 MemoryFileSystem 的实例，如果不是，用 MemoryFileSystem 的实例替换 compiler 之前的 outputFileSystem。这样 bundle.js 文件代码就作为一个简单 javascript 对象保存在了内存中，当浏览器请求 bundle.js 文件时，devServer就直接去内存中找到上面保存的 javascript 对象返回给浏览器端。</li>
</ul>

<p>关于webpack-dev-server 的核心内容</p>

<ul>
<li>webpack, 负责编译代码</li>
<li>webpack-dev-server，主要提供了 in-memory 内存文件系统，他会把webpack的outputFileSystem 替换成一个 inMemoryFileSystem，并且拦截全部的浏览器请求，从这个文件系统中把结果取出来返回。</li>
<li>express，作为服务器</li>
</ul>

<h4 id="toc_17">总结</h4>

<p>webpack的主要编译都按照下面的钩子调用顺序执行。</p>

<ul>
<li>Compiler:beforeRun 清除缓存</li>
<li>Compiler:run 注册缓存数据钩子</li>
<li>Compiler:beforeCompile</li>
<li>Compiler:compile 开始编译</li>
<li>Compiler:make 从入口分析依赖以及间接依赖模块，创建模块对象</li>
<li>Compilation:buildModule 模块构建</li>
<li>Compiler:normalModuleFactory 构建</li>
<li>Compilation:seal 构建结果封装， 不可再更改</li>
<li>Compiler:afterCompile 完成构建，缓存数据</li>
<li>Compiler:emit 输出到dist目录</li>
<li>一个 Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。</li>
</ul>

<hr>

<p>and~~~</p>

<ul>
<li><p>Compilation 对象也提供了很多事件回调供插件做扩展。</p></li>
<li><p>Compilation中比较重要的部分是assets,如果我们要借助webpack来生成文件,就要在assets上添加对应的文件信息。</p></li>
</ul>

<p>参考：<a href="https://segmentfault.com/a/1190000017013855?utm_source=tag-newest">干货！撸一个webpack插件(内含tapable详解+webpack流程)</a></p>

<h4 id="toc_18">问题</h4>

<p>webpack 整个体系非常复杂，在我看来比react 好读一些。
还有关于HMR的原理、动态加载可以自己去尝试研究下</p>




</body>

</html>
